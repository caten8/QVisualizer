<!DOCTYPE html> 
<html lang="en"> 
    <head>
        <meta charset="utf-8">
        <title>BarTree v0.01</title>
        <script src="raphael.js"></script>
        <script src="jquery-1.4.4.js"></script>
        <style type="text/css">
          #holder {
            border: 1px solid black;
          }
        </style>
        <script type="text/javascript">
          function BarTreeView(domID, width, height, data) {
            if (!(this instanceof arguments.callee)) {
              return new arguments.callee(arguments);
            }

            var self = this;

            // Hardcoded settings.
            self.spacing = 10;
            self.levelSpacing = 80;
            self.mouseColor = '#1F1AB2';
            self.keyboardColor = '#FFC200';            
            self.fontAttributes = {
              'font-size'   : 35,
              'font-weigh'  : 800,
              'fill'        : '#ddd',
              'stroke'      : '#4A5054',
              'stoke-widht' : 1
            };            

            self.init = function() {
              self.paper = new Raphael(domID, width, height);

              // Incoming settings.
              self.width  = width;
              self.height = height;
              self.data   = data;

              // Convert incoming hierarchical data into simple levels.
              self.levels = self.parseData(self.data);

              // Dynamically calculated settings.
              self.barWidth = (  self.width                                    // Entire width
                               - (2 * self.spacing)                            // minus the spacing at the edges
                               - (self.levels.length - 1) * self.levelSpacing  // minus the spacing between the levels
                              )
                               / self.levels.length;                           // divided by the number of levels = width of each bar.

              // Determine the "busiest" level, i.e. the one with the most
              // blocks. We will assign this level the minimum amount of
              // vertical spacing. Based on the availableHeight variable (
              // which is the height available for drawing blocks) in that
              // level, we will dynamically increase the vertical spacing in
              // less busy levels.
              var busiestLevel = 0;
              var busiestLevelNumBlocks = 0;
              for (var l = 0; l < self.levels.length; l++) {
                var numBlocks = self.levels[l].blocks.length;
                if (numBlocks > busiestLevelNumBlocks) {
                  busiestLevel = l;
                  busiestLevelNumBlocks = numBlocks;
                }
              }
              var numBlocksInBusiestLevel = self.levels[busiestLevel].blocks.length;
              var availableHeight = self.height - (numBlocksInBusiestLevel + 1) * self.spacing;

              // Draw!
              var xOffset = self.spacing;
              for (var l = 0; l < self.levels.length -1; l++) {
                var numBlocks = self.levels[l].blocks.length;

                // Calculate the vertical spacing based on the availableHeight
                // for the busiest level.
                var numSpacings = numBlocks + 1;
                var levelAvailableHeight = self.height - (numSpacings * self.spacing);
                var additionalSpacingHeight = levelAvailableHeight - availableHeight;
                var verticalSpacing = ((numSpacings * self.spacing) + additionalSpacingHeight) / numSpacings;

                // Increase xOffset for nested levels.
                if (l > 0) {
                  xOffset += self.barWidth + self.levelSpacing;
                }

                var yOffset = verticalSpacing;
                for (var b = 0; b < numBlocks; b++) {
                  var currentBlock = self.levels[l].blocks[b];
                  
                  var finalFrequency = currentBlock.finalFrequency;
                  var barHeight = finalFrequency * availableHeight;
                  console.log('level' + l +', block ' + b + ': ' + barHeight);
                  
                  // Draw block, and store where it was drawn as well as a
                  // reference to the drawn block. Analogously for the block
                  // label.
                  currentBlock.xOffset = xOffset;
                  currentBlock.yOffset = yOffset;
                  currentBlock.yConnectedMax = 0;
                  currentBlock.drawn = self.paper.rect(xOffset, yOffset, self.barWidth, barHeight)
                                                 .attr(self.rectAttributes(self.mouseColor));
                  currentBlock.drawnLabel = self.paper.text(xOffset + self.barWidth / 2, yOffset + barHeight / 2, currentBlock.label)
                                                      .attr(self.fontAttributes);

                  // Draw connection between this block and its parent block
                  // in the previous (higher) level.
                  if (l > 0) {
                    var parentBlock = currentBlock.parentBlock;
                    var parentBlockX = parentBlock.xOffset + self.barWidth;
                    var parentBlockY = parentBlock.yOffset + parentBlock.yConnectedMax;
                    parentBlock.yConnectedMax += barHeight;
                    self.drawConnector(parentBlockX, parentBlockY, xOffset, yOffset, barHeight, self.rectAttributes(self.mouseColor));
                  }

                  // Increase yOffset for the next block.
                  yOffset += barHeight + verticalSpacing;
                }
              }              
            };

            // Source: http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json.
            self.isEmpty = function(obj) {
                for(var prop in obj) {
                    if(obj.hasOwnProperty(prop))
                        return false;
                }

                return true;
            }

            // parses hierarchical data structure into simple array of levels,
            // with blocks in each level
            self.parseData = function(subTree, levels) {
              var frequencySumCheck = 0.0;
// console.log('new level');
              if (levels === undefined) {
                levels = [];
              }

              
              nextSubTree = {};

              level = {};
              level.blocks = [];
              for (label in subTree) {
                var frequency = subTree[label].frequency;
                var parentFrequency = (subTree[label].parentFrequency === undefined) ? 1.0 : subTree[label].parentFrequency;
                delete subTree[label].parentFrequency;
                var finalFrequency = parentFrequency * frequency;
                frequencySumCheck += finalFrequency;
                block = {
                  'label'          : label,
                  'frequency'      : frequency,
                  'parentFrequency': parentFrequency,
                  'finalFrequency' : finalFrequency,
                };
                if (subTree[label].parentBlock !== undefined) {
                  block.parentBlock =  subTree[label].parentBlock;
                }
                level.blocks.push(block);

// console.log(label);
// console.log(finalFrequency);
                if (subTree[label].children !== undefined) {
                  for (child in subTree[label].children) {
                    if (nextSubTree[child] == undefined) {
                      nextSubTree[child] = subTree[label].children[child];
                      nextSubTree[child].parentBlock = block; // MIH
                      nextSubTree[child].parentFrequency = finalFrequency;
                    }
                    // Automatically merge blocks in deeper levels that have
                    // the same label!
                    else {
// console.log("YARRRRRR");
// console.log(subTree[label].children[child]);
                      nextSubTree[child].frequency += subTree[label].children[child].frequency;
                      nextSubTree[child].parentFrequency += finalFrequency;                      
                    }
                  }
                }
              }
// console.log('frequency sum check:');
// console.log(frequencySumCheck);

              if (level.blocks.length > 0)
                levels.push(level);
// console.log('\t\tnext subtree:');
// console.log(nextSubTree);
              // console.log(self.isEmpty(nextSubTree));

              if (!self.isEmpty(nextSubTree))
                return self.parseData(nextSubTree, levels);
              else
                return levels;
            };

            self.rectAttributes = function(color, opacity) {
              if (opacity === undefined) {
                var opacity = 0.8;
              }

              return {
                'fill'           : color,
                'stroke'         : color,
                'fill-opacity'   : opacity,
                'stroke-opacity' : opacity
              };
            };

            self.drawConnector = function(leftTopX, leftTopY, rightTopX, rightTopY, height, params) {
              return self.paper.path([
                "M", leftTopX, leftTopY,
                "L", rightTopX, rightTopY,
                "v", height,
                "L", leftTopX, leftTopY + height,
                "z"
              ]).attr(params);
            }

            self.init();
          };




          var data = {
            'mouse' : {
              'frequency' : 0.8,
              'children'  : {
                'click left' : {
                  'frequency' : 0.7,
                  'children'  : {
                    'none'  : { 'frequency' : 0.8 },
                    'CTRL'  : { 'frequency' : 0.1 },
                    'other' : { 'frequency' : 0.1 }
                  }
                },
                'double click left' : {
                  'frequency' : 0.1,
                  'children'  : {
                    'none' : { 'frequency' : 1.0 }
                  }
                },
                'click right' : {
                  'frequency' : 0.1,
                  'children'  : {
                    'none' : { 'frequency' : 1.0 }
                  }
                },
                'other' : {
                  'frequency' : 0.1,
                  'children'  : {
                    'none' : { 'frequency' : 1.0 }
                  }
                }
              }
            },
            'keyboard' : {
              'frequency' : 0.2,
              'children' : {
                'release' : {
                  'frequency' : 0.8,
                  'children' : {
                    'P'      : { 'frequency' : 0.4 },
                    'CTRL+Z' : { 'frequency' : 0.4 },
                    'other'  : { 'frequency' : 0.2 }
                  }
                },
                'press' : {
                  'frequency' : 0.2,
                  'children'  : {
                    'other' : { 'frequency' : 1.0 }
                  }
                }
              }
            }
          };
          $().ready(function() {
            var vis3 = new BarTreeView("holder", 1000, 1000, data);
          });
        </script> 
    </head> 
    <body> 
        <div id="holder"></div> 
    </body> 
</html>
